// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class InstaIndex extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("masterAddress", Value.fromBytes(Bytes.empty()));
    this.set("listAddress", Value.fromBytes(Bytes.empty()));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
    this.set("versionCount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save InstaIndex entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save InstaIndex entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("InstaIndex", id.toString(), this);
    }
  }

  static load(id: string): InstaIndex | null {
    return changetype<InstaIndex | null>(store.get("InstaIndex", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get masterAddress(): Bytes {
    let value = this.get("masterAddress");
    return value!.toBytes();
  }

  set masterAddress(value: Bytes) {
    this.set("masterAddress", Value.fromBytes(value));
  }

  get newMasterAddress(): Bytes | null {
    let value = this.get("newMasterAddress");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set newMasterAddress(value: Bytes | null) {
    if (!value) {
      this.unset("newMasterAddress");
    } else {
      this.set("newMasterAddress", Value.fromBytes(<Bytes>value));
    }
  }

  get listAddress(): Bytes {
    let value = this.get("listAddress");
    return value!.toBytes();
  }

  set listAddress(value: Bytes) {
    this.set("listAddress", Value.fromBytes(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }

  get versionCount(): BigInt {
    let value = this.get("versionCount");
    return value!.toBigInt();
  }

  set versionCount(value: BigInt) {
    this.set("versionCount", Value.fromBigInt(value));
  }
}

export class AccountModule extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("connectorsAddress", Value.fromBytes(Bytes.empty()));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccountModule entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save AccountModule entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("AccountModule", id.toString(), this);
    }
  }

  static load(id: string): AccountModule | null {
    return changetype<AccountModule | null>(store.get("AccountModule", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get connectorsAddress(): Bytes {
    let value = this.get("connectorsAddress");
    return value!.toBytes();
  }

  set connectorsAddress(value: Bytes) {
    this.set("connectorsAddress", Value.fromBytes(value));
  }

  get version(): BigInt | null {
    let value = this.get("version");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set version(value: BigInt | null) {
    if (!value) {
      this.unset("version");
    } else {
      this.set("version", Value.fromBigInt(<BigInt>value));
    }
  }

  get check(): string | null {
    let value = this.get("check");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set check(value: string | null) {
    if (!value) {
      this.unset("check");
    } else {
      this.set("check", Value.fromString(<string>value));
    }
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class Check extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("version", Value.fromBigInt(BigInt.zero()));
    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("accountModule", Value.fromString(""));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Check entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Check entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Check", id.toString(), this);
    }
  }

  static load(id: string): Check | null {
    return changetype<Check | null>(store.get("Check", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): BigInt {
    let value = this.get("version");
    return value!.toBigInt();
  }

  set version(value: BigInt) {
    this.set("version", Value.fromBigInt(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get accountModule(): string {
    let value = this.get("accountModule");
    return value!.toString();
  }

  set accountModule(value: string) {
    this.set("accountModule", Value.fromString(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class DSA extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("owner", Value.fromBytes(Bytes.empty()));
    this.set("origin", Value.fromBytes(Bytes.empty()));
    this.set("createdBy", Value.fromBytes(Bytes.empty()));
    this.set("walletAddress", Value.fromBytes(Bytes.empty()));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DSA entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DSA entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DSA", id.toString(), this);
    }
  }

  static load(id: string): DSA | null {
    return changetype<DSA | null>(store.get("DSA", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get origin(): Bytes {
    let value = this.get("origin");
    return value!.toBytes();
  }

  set origin(value: Bytes) {
    this.set("origin", Value.fromBytes(value));
  }

  get createdBy(): Bytes {
    let value = this.get("createdBy");
    return value!.toBytes();
  }

  set createdBy(value: Bytes) {
    this.set("createdBy", Value.fromBytes(value));
  }

  get version(): BigInt | null {
    let value = this.get("version");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set version(value: BigInt | null) {
    if (!value) {
      this.unset("version");
    } else {
      this.set("version", Value.fromBigInt(<BigInt>value));
    }
  }

  get walletAddress(): Bytes {
    let value = this.get("walletAddress");
    return value!.toBytes();
  }

  set walletAddress(value: Bytes) {
    this.set("walletAddress", Value.fromBytes(value));
  }

  get enabledAuthorities(): Array<Bytes> | null {
    let value = this.get("enabledAuthorities");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytesArray();
    }
  }

  set enabledAuthorities(value: Array<Bytes> | null) {
    if (!value) {
      this.unset("enabledAuthorities");
    } else {
      this.set("enabledAuthorities", Value.fromBytesArray(<Array<Bytes>>value));
    }
  }

  get logCasts(): Array<string> | null {
    let value = this.get("logCasts");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set logCasts(value: Array<string> | null) {
    if (!value) {
      this.unset("logCasts");
    } else {
      this.set("logCasts", Value.fromStringArray(<Array<string>>value));
    }
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class Cast extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("dsa", Value.fromString(""));
    this.set("origin", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
    this.set("version", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Cast entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Cast entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Cast", id.toString(), this);
    }
  }

  static load(id: string): Cast | null {
    return changetype<Cast | null>(store.get("Cast", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get dsa(): string {
    let value = this.get("dsa");
    return value!.toString();
  }

  set dsa(value: string) {
    this.set("dsa", Value.fromString(value));
  }

  get origin(): Bytes {
    let value = this.get("origin");
    return value!.toBytes();
  }

  set origin(value: Bytes) {
    this.set("origin", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }

  get spells(): Array<string> | null {
    let value = this.get("spells");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set spells(value: Array<string> | null) {
    if (!value) {
      this.unset("spells");
    } else {
      this.set("spells", Value.fromStringArray(<Array<string>>value));
    }
  }

  get version(): BigInt {
    let value = this.get("version");
    return value!.toBigInt();
  }

  set version(value: BigInt) {
    this.set("version", Value.fromBigInt(value));
  }
}

export class Spell extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("logCast", Value.fromString(""));
    this.set("target", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Spell entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Spell entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Spell", id.toString(), this);
    }
  }

  static load(id: string): Spell | null {
    return changetype<Spell | null>(store.get("Spell", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get logCast(): string {
    let value = this.get("logCast");
    return value!.toString();
  }

  set logCast(value: string) {
    this.set("logCast", Value.fromString(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    return value!.toBytes();
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get targetName(): string | null {
    let value = this.get("targetName");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set targetName(value: string | null) {
    if (!value) {
      this.unset("targetName");
    } else {
      this.set("targetName", Value.fromString(<string>value));
    }
  }

  get eventName(): string | null {
    let value = this.get("eventName");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set eventName(value: string | null) {
    if (!value) {
      this.unset("eventName");
    } else {
      this.set("eventName", Value.fromString(<string>value));
    }
  }

  get eventParams(): Bytes | null {
    let value = this.get("eventParams");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set eventParams(value: Bytes | null) {
    if (!value) {
      this.unset("eventParams");
    } else {
      this.set("eventParams", Value.fromBytes(<Bytes>value));
    }
  }
}

export class Connector extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("connectorAddress", Value.fromBytes(Bytes.empty()));
    this.set("connectorName", Value.fromString(""));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Connector entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Connector entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Connector", id.toString(), this);
    }
  }

  static load(id: string): Connector | null {
    return changetype<Connector | null>(store.get("Connector", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get connectorAddress(): Bytes {
    let value = this.get("connectorAddress");
    return value!.toBytes();
  }

  set connectorAddress(value: Bytes) {
    this.set("connectorAddress", Value.fromBytes(value));
  }

  get connectorName(): string {
    let value = this.get("connectorName");
    return value!.toString();
  }

  set connectorName(value: string) {
    this.set("connectorName", Value.fromString(value));
  }

  get chief(): Array<string> | null {
    let value = this.get("chief");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set chief(value: Array<string> | null) {
    if (!value) {
      this.unset("chief");
    } else {
      this.set("chief", Value.fromStringArray(<Array<string>>value));
    }
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class Chief extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("isChief", Value.fromBoolean(false));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Chief entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Chief entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Chief", id.toString(), this);
    }
  }

  static load(id: string): Chief | null {
    return changetype<Chief | null>(store.get("Chief", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get isChief(): boolean {
    let value = this.get("isChief");
    return value!.toBoolean();
  }

  set isChief(value: boolean) {
    this.set("isChief", Value.fromBoolean(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class InstaImplementation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save InstaImplementation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save InstaImplementation entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("InstaImplementation", id.toString(), this);
    }
  }

  static load(id: string): InstaImplementation | null {
    return changetype<InstaImplementation | null>(
      store.get("InstaImplementation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get Implementations(): Array<string> | null {
    let value = this.get("Implementations");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set Implementations(value: Array<string> | null) {
    if (!value) {
      this.unset("Implementations");
    } else {
      this.set("Implementations", Value.fromStringArray(<Array<string>>value));
    }
  }

  get defaultImplementation(): Bytes | null {
    let value = this.get("defaultImplementation");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set defaultImplementation(value: Bytes | null) {
    if (!value) {
      this.unset("defaultImplementation");
    } else {
      this.set("defaultImplementation", Value.fromBytes(<Bytes>value));
    }
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}

export class Implementation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("instaImplementation", Value.fromString(""));
    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("signatures", Value.fromBytesArray(new Array(0)));
    this.set("defaultStatus", Value.fromBoolean(false));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Implementation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Implementation entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Implementation", id.toString(), this);
    }
  }

  static load(id: string): Implementation | null {
    return changetype<Implementation | null>(store.get("Implementation", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get instaImplementation(): string {
    let value = this.get("instaImplementation");
    return value!.toString();
  }

  set instaImplementation(value: string) {
    this.set("instaImplementation", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get signatures(): Array<Bytes> {
    let value = this.get("signatures");
    return value!.toBytesArray();
  }

  set signatures(value: Array<Bytes>) {
    this.set("signatures", Value.fromBytesArray(value));
  }

  get defaultStatus(): boolean {
    let value = this.get("defaultStatus");
    return value!.toBoolean();
  }

  set defaultStatus(value: boolean) {
    this.set("defaultStatus", Value.fromBoolean(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }
}
